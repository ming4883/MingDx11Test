/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "../JuceLibraryCode/JuceHeader.h"

#include <DirectXMath.h>
using namespace DirectX;

using namespace mdk;

//==============================================================================
class Example02 : public D3D11Demo
{
public:
    Example02()
    {
    }
    
    ~Example02()
    {
    }

    struct cb_align CBAppData
    {
        float time;
    };

    bool demoStartup()
    {
        Hold<ID3DBlob> pscode = loadShaderFromBinaryData ("Test.pso");
        Hold<ID3DBlob> vscode = loadShaderFromBinaryData ("Test.vso");

        if (vs_.set (createVertexShader (vscode)).isNull())
            return false;

        if (ps_.set (createPixelShader (pscode)).isNull())
            return false;

        D3D11_INPUT_ELEMENT_DESC idesc;
        idesc.SemanticName = "POSITION";
        idesc.SemanticIndex = 0;
        idesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
        idesc.InputSlot = 0;
        idesc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
        idesc.AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
        idesc.InstanceDataStepRate = 0;

        if (il_.set (createInputLayout (&idesc, 1, vscode)).isNull())
            return false;

        XMFLOAT4 vtx[] = {
            XMFLOAT4 ( 0.0f, 1.0f, 0.0f, 1.0f),
            XMFLOAT4 ( 1.0f,-1.0f, 0.0f, 1.0f),
            XMFLOAT4 (-1.0f,-1.0f, 0.0f, 1.0f),
        };

        if (vb_.set (createVertexBuffer (numElementsInArray (vtx), false, vtx)).isNull())
            return false;

        if (tx_.set (createTexture2DFromBinaryData ("Test.png")).isNull())
            return false;

        if (sv_.set (createShaderResourceView (tx_)).isNull())
            return false;

        if (cb_.set (createConstantBuffer<CBAppData>()).isNull())
            return false;

        ScopedPointer<InputStream> stream = binDataGet ("Rabbit.babylon");

        if (stream)
        {
            BabylonFile file;
            file.read (stream);
        }

        return true;
    }

    void demoShutdown()
    {
        vs_.set (nullptr);
        ps_.set (nullptr);
        il_.set (nullptr);
        vb_.set (nullptr);
        tx_.set (nullptr);
        sv_.set (nullptr);
        cb_.set (nullptr);
    }

    void demoUpdate ()
    {
        XMFLOAT4A rgba (0.25f, 0.25f, 1.0f, 1.0f);
        D3D11_VIEWPORT vp = getViewport (0.0f, 0.0f, 1.0f, 1.0f);
        
        CBAppData appData;
        appData.time = 1.0f + cosf (timeGetAccumMS<float>() / 2048.0f) * 0.5f + 0.5f;
        updateBuffer (cb_, appData);
        
        d3dIMContext_->OMSetRenderTargets (1, d3dBackBufRTView_, nullptr);
        d3dIMContext_->ClearRenderTargetView (d3dBackBufRTView_, (float*)&rgba);
        d3dIMContext_->RSSetViewports (1, &vp);

        UINT stride = sizeof (XMFLOAT4);
        UINT offset = 0;
        
        d3dIMContext_->IASetVertexBuffers (0, 1, vb_, &stride, &offset);
        d3dIMContext_->IASetInputLayout (il_);
        d3dIMContext_->IASetPrimitiveTopology (D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

        d3dIMContext_->VSSetShader (vs_, nullptr, 0);
        d3dIMContext_->VSSetConstantBuffers (0, 1, cb_);

        d3dIMContext_->PSSetShader (ps_, nullptr, 0);
        d3dIMContext_->PSSetShaderResources (0, 1, sv_);
        d3dIMContext_->PSSetSamplers (0, 1, d3dSampWrapPoint_);

        d3dIMContext_->Draw (3, 0);

        d3dSwapchain_->Present (0u, 0u);
    }

    Hold<ID3D11VertexShader> vs_;
    Hold<ID3D11PixelShader> ps_;
    Hold<ID3D11InputLayout> il_;
    Hold<ID3D11Buffer> vb_;
    Hold<ID3D11Texture2D> tx_;
    Hold<ID3D11ShaderResourceView> sv_;
    Hold<ID3D11Buffer> cb_;
};

//==============================================================================
class Example02Application  : public DemoApplication<Example02>
{
public:
    const String getApplicationName() override       { return ProjectInfo::projectName; }
    const String getApplicationVersion() override    { return ProjectInfo::versionString; }
    bool moreThanOneInstanceAllowed() override       { return true; }
};

//==============================================================================
// This macro generates the main() routine that launches the app.
START_JUCE_APPLICATION (Example02Application)
